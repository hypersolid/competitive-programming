class Solution {
  int N;
  int M;
  boolean[] visited;
  int[] rank;
  int[] arity;

  int[][] graph;
  int[] initial;
  HashMap<Integer, Integer> infectionPoints;

  void dfs(int i, int infectionIndex) {
    visited[i] = true;
    for (int j = 0; j < N; j++) {
      if (graph[i][j] != 1 || visited[j]) {
        continue;
      }
      arity[infectionIndex]++;
      if (infectionPoints.containsKey(j)) {
        rank[infectionIndex]++;
        rank[infectionPoints.get(j)] = -1;
      }
      dfs(j, infectionIndex);
    }
  }

  public int minMalwareSpread(int[][] graph, int[] initial) {
    // setup helper vars
    N = graph.length;
    M = initial.length;
    this.graph = graph;
    this.initial = initial;

    visited = new boolean[N];
    rank = new int[M];
    arity = new int[M];

    // make set for quick lookups of infection points
    infectionPoints = new HashMap<>();
    for (int i = 0; i < M; i++) {
      infectionPoints.put(initial[i], i);
    }

    // infestation starts (!)
    for (int i = 0; i < M; i++) {
      // rank -1 means that point was infested earlier
      if (visited[initial[i]]) {
        continue;
      }
      arity[i] = 1;
      rank[i] = 1;
      dfs(initial[i], i);
    }

    int maxArity = Integer.MIN_VALUE;
    int maxInitialElement = Integer.MAX_VALUE;
    for (int i = 0; i < M; i++) {
      if (rank[i] == 1 || arity[i] == 1) {
        if (maxArity < arity[i]) {
          maxArity = arity[i];
          maxInitialElement = initial[i];
        }
        if (maxArity == arity[i] && maxInitialElement > initial[i]) {
          maxInitialElement = initial[i];
        }
      }
    }
    if (maxInitialElement == Integer.MAX_VALUE) {
      for (int i = 0; i < M; i++) {
        if (maxInitialElement > initial[i]) {
          maxInitialElement = initial[i];
        }
      }
    }
    return maxInitialElement;
  }
}
